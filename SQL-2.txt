테이블에서 모든 열(COLUMN) 출력하기

select  *
 from  emp; 
 - emp 테이블에서 모든 열(컬럼)을 조회해라!

select *
  from  dept; 
 - dept 테이블에서 모든 열(컬럼)을 조회해라!
 - * 은 모든 컬럼을 대표한다.


테이블에서 특정 열(COLUMN) 선택하기

select  ename, sal -->컬럼 
   from   emp ;  -->테이블
 -emp 테이블에서 ename(사원 이름), sal(사원 월급)을 조회해라!

select  ename, job, hiredate, deptno
   from  emp;
 -emp 테이블에서 ename(사원 이름), job(직업), hiredate(입사일), deptno(부서 번호)를 조회해라!


컬럼 별칭을 사용하여 출력되는 컬럼명 변경하기

* 컬럼명 대신에 다른 컬럼명을 지정할 때 사용하는 문법

[select 컬럼 as '하고 싶은 컬럼명' from 테이블;]

select ename as 이름, sal as 월급
 from emp;
- ename을 이름, sal을 조회하는데 이름과 월급이라고 한글로 출력해라! 

select ename as "Employee name", sal as "Salary"
  from emp;
- ename과 sal을 Employee name, Salary로 출력해라!

※ 컬럼 별칭에 대소문자를 구분하고 싶다거나 공백 문자나 특수문자를 넣으려면 양쪽에
   더블 쿼테이션 마크를 둘러줘야 한다.


연결 연산자 사용하기 (||)

* 두 컬럼의 데이터를 연결해서 출력하는 연산자

[select 컬럼 || '아무 말' || 컬럼명 from 테이블;]


select  ename || ' 의 직업은 '  ||  job  || ' 입니다. '
 from   emp;


중복된 데이터를 제거해서 출력하기(DISTINCT)

* 컬럼명 앞에 작성하고 실행하면 중복된 데이터를 제거하고 출력한다.

select job from emp;
select distinct job from emp;


데이터를 정렬해서 출력하기 (ORDER  BY)

* order by 절은 데이터를 정렬하는 절이고 select 문장에 맨 마지막에 기술한다.
* 정렬할 컬럼명 정렬방법 :
asc : 낮은값부터 높은값 순으로
desc : 높은값부터 낮은값 순으로

예제 : 월급이 높은 순으로 이름과 월급을 출력하기
select ename, sal
  from  emp
  order by sal desc;

select ename, sal
  from  emp
  order by sal asc;

select ename, sal
  from  emp
  order by sal;

보이는 것처럼 오름차순(asc) 또는 내림차순(desc)을 명시하지 않으면 디폴트 값은 asc다.


또한
 select ename, job, hiredate
  from  emp
  order  by 2 asc, 3 asc; 

위와 같이 order by를 2개 이상 해주는 것도 가능하며, select 절의 컬럼명을 간단하게 순서대로 1,2,3으로 대체해서 작성할 수 있다.


where 절 (숫자 데이터 검색)

* where 절을 사용하면 특정 조건에 대한 데이터만 선별해서 출력할 수 있다

* 기본 비교 연산자

 >, <, >=, <=, =,  !=, <>, ^=
이 중에 [!=,<>,^=]-->이것들 전부 다 같지 않다는 뜻.


예제 : 월급이 3000 이상인 사원들의 이름과 월급을 출력하기

select ename, sal
   from emp
   where sal>=3000;

예제 : 직업이 SALESMAN이 아닌 사원들의 이름과 직업을 출력하기

select ename, job
   from emp
   where job!='SALESMAN';

select  ename, hiredate, deptno
   from  emp
   where deptno = 20
   order by 2 desc;

부서 번호가 20인 사원들의 이름, 고용일, 부서 번호를 출력하고 최근에 고용된 순서부터 정렬


8. where 절 - 2 (문자와 날짜 검색)

* 숫자가 아닌 문자를 검색할 때는 문자 양쪽에 싱글 쿼테이션 마크('')를 둘러줘야 한다.

select  ename, sal
 from emp
 where ename='SCOTT'; 

또한 문자열은 대문자를 구분하기 때문에 소문자인 scott으로 검색하면 다른 것으로 인식되어 검색 결과가 출력되지 않는다.

*  기타 비교연산자  4가지

 1. between .. and
 2. like
 3. is null
 4. in

1. BETWEEN AND

값이 A와 B 사이인 값들만 조건부 출력한다.

where 컬럼명 between A and B

예제 : 월급이 1000, 3000 사이인 사원들의 이름과 월급을 출력하기

select ename, sal
  from emp
  where sal between 1000 and 3000;

반대로 A와 B사이인 경우를 제외하고 선택할 수도 있다.

where not 컬럼명 between A and B

예제 :  월급이 1000, 3000 사이가 아닌 사원들의 이름과 월급을 출력하기

select ename, sal
  from emp
  where not sal between 1000 and 3000;

select  ename, sal
  from  emp
  where  ename = 'A%';


2. LIKE

like를 사용하면 특정 문자가 포함되어 있는 문자를 검색할 수 있다.

like 연산자를 사용할 때 사용하는 키워드 2가지 :

  1.  %  :  와일드 카드 :  이 자리에 뭐가 와도 관계없고 그 갯수가 몇 개가 되든 관계없다. 

  2.  _   :  언더바        :  이 자리에 뭐가 와고 관계없는데 자릿수는 한개여야 한다. 

select  ename, sal
  from  emp
  where  ename  like  'M%';

select  ename, sal
  from  emp
  where  ename  like  '%M%';

select  ename, sal
  from  emp
  where  ename  like  '_M%';

 -- M으로 시작하는 이름을 가진 사원의 이름과 월급을 출력

 -- M이 포함된 이름을 가진 사원의 이름과 월급을 출력 

 -- M이 이름의 두 번째 자리에 있는 사원의 이름과 월급을 출력



3. IS NULL

NULL 값을 조회할 때 사용하는 연산자


예제 : 보너스가 입력되지 않은 사원을 출력하기

select ename, comm
   from emp
   where comm = null;


* comm=null 로 조회할 수 없다.

왜냐하면 null은 알 수 없는 값이므로 비교 연산자인 '='로는 조회할 수 없다.

기타 비교 연산자인 is null을 사용해야 한다.


예제 : 보너스가 입력되지 않은 사원을 출력하기

select ename, comm
   from emp
   where comm is null;

between 처럼 반대의 경우도 조건을 줄 수 있다.

select ename, comm
   from emp
   where comm is not null;


참고로 null은 알 수 없는 값이고, 0은 명확한 값으로 둘은 전혀 다르다.


4. IN

where 절의 검색조건에서 여러개의 행을 비교할 때는 in 을 사용하는 게 편하다.

where 컬럼명 in ( 조건1, 조건2, 조건3 )

예제 : 사원 번호가 7788, 7902, 6703 중 하나인 사원을 찾아 출력하기 

select   empno,  ename
    from   emp
    where   empno  in  ( 7788, 7902, 6703 );

반대의 경우도 역시나 가능하다.

예제 : 직업이 SALESMAN, ANAYLST가 아닌 사원들의 이름과 직업을 출력하기

select  ename, job
  from  emp
  where  job  not in  ('SALESMAN', 'ANALYST'); 

논리 연산자 : and, or, not

*  True  and  True  면  True 여서 결과가 출력이 된다.

   False  and  True  면  False  여서 결과가 출력이 안 된다

   False   or   True   는  True 이므로 결과가 출력이 된다. 


예제 : 직업이 SALESMAN 이고 월급이 1400 이상인 사원만 출력

select ename, sal,  job
 from emp
 where  job ='SALESMAN' and sal >= 1400;

예제 : 직업이 SALESMAN 이거나 월급이 1400 이상인 사원 출력

select ename, sal,  job
 from emp
 where  job ='SALESMAN' or sal >= 1400;

예제 : 이메일의 도메인이 naver나 gmail이 아닌 학생 출력

select ename, email
    from emp12
    where email not like '%gmail%' and email not like '%naver%';

대소문자 변환 함수 (UPPER, LOWER, INITCAP)

upper: 대문자로 출력하는 함수

lower : 소문자로 출력하는 함수

initcap: 첫번째 철자는 대문자로 출력하고 나머지는 다 소문자로 출력하는 함수

select   upper(ename), lower(ename), initcap(ename)
 from  emp;

문자에서 특정 철자를 추출하는 함수(SUBSTR)

예 : SUBSTR( 컬럼명 , 2 , 5 ) --> 컬럼명에 들어있는 값의 2번째 자리 기준으로 5개의 문자를 추출하여 반환.

만약 'BIG DATA'라는 값이 들어있었다면 --> 'IG DA' 를 반환

substr를 활용한 검색

예제 : 성씨가 이씨, 유씨, 김씨 인 학생들의 이름을 출력하시오!

select  ename
 from  emp12
 where substr(ename, 1, 1) in ('이', '김', '유');

문자열의 길이를 출력하는 함수 ( LENGTH )

예 : length(컬럼명) --> 컬럼명 안의 값인 문자열의 길이를 반환

만약 scott 이 들어있었다면 5를 반환한다.

예제 : 이름과 이메일과 이메일의 길이를 출력하는데 이메일의 길이가 가장 긴 것부터 출력하시오

select ename,email,length(email)

 from emp12

 order by length(email) desc;

문자에서 특정 철자의 위치 출력하기(INSTR)

특정 철자의 자릿수를 출력하는 함수

instr( 컬럼명, 특정 철자)

예 : instr('smith', 't') --> 4를 반환 ** 이 경우는 예시를 위해 컬럼명이 아니라 직접 값을 준 경우이다.

예제 : 우리반 테이블에서 이메일을 출력하고 그 옆에 이메일에서 @가 몇 번째 자리에 있는지 출력하시오

select email,instr(email,'@')
 from emp12;

특정 철자를 다른 철자로 변경하기(REPLACE)


특정 철자를 다른 철자로 변경하는 함수

replace( 컬럼명, 특정 철자, 바꿀 철자 )

replace('smith', 'm', 'k') --> skith를 반환 ** 이 때 실제 데이터 테이블 값이 바뀌는 것은 아니다. (출력만)


예제 : 사원들의 이름과 월급을 출력하는데, 0을 *로 출력하기

select ename,  replace(sal, 0, '*')
 from  emp;


특정 철자를 N개 만큼 채우기(LPAD, RPAD)


항상 고정된 자릿수를 보장하기 위해서 필요한 함수


lpad( 컬럼명, 전체 자릿수, 채워넣을값 )

rpad( 컬럼명, 전체 자릿수, 채워넣을값 )

select  sal,  lpad(sal, 10, '*'), rpad(sal, 10, '*') 
  from   emp;


공백 잘라내기(TRIM, RTRIM, LTRIM)

공백을 잘라낼때 많이 사용하는 함수. 
공백 때문에 데이터 검색이 안되는 경우가 종종 있기 때문에 trim 함수를 자주 사용한다. 


ltrim :   왼쪽에 있는 공백을 잘라버리겠다.

rtrim :   오른쪽에 있는 공백을 잘라버리겠다

trim  :   양쪽에 있는 공백을 잘라버리겠다.

숫자 함수 

  1.  round :  반올림하는 함수

  2.  trunc  :  잘라내서 버리는 함수 

  3.  mod   :  나눈 나머지 값을 출력하는 함수


반올림해서 출력하기(ROUND)            

예제: 

select round( 786.567,  -1 ), round( 786.567 ), round( 786.567, 1 )

 from dual; ** dual 은 이렇게 임시로 값을 확인하고 싶을 때 사용하기 편한 임시 테이블이다.

round( 숫자, n ) --> n번째 자리까지 반올림하여 반환

     7  8   6   .   5  6  7  

    -3 -2  -1  0  1  2  3


숫자를 버리고 출력하기(TRUNC)

예제 : 

select trunc( 786.567,  -1 ), trunc( 786.567 ), trunc( 786.567, 1 )
 from dual;

나눈 나머지 값 출력하기(MOD)

mod( 숫자(a), 나눌 값(b) ) --> a를 b로 나눈 뒤 나머지 c를 반환

select mod(24,2), mod(25,2)
 from dual;

mod 함수 활용 : 주로 짝수, 요일을 확인할 때 활용할 수 있다.


예제 : 나이가 짝수인 학생들의 성별과 나이를 출력하기

select gender, age
   from emp12
   where mod(age,2) = 0;

날짜 함수 

  1.  sysdate :  오늘 날짜

  2.  months_between  :  날짜 사이의 개월 수 

  3.  next_day  :  다음 주 특정 요일의 날짜

  4.  last_day  : 해당 달의 마지막 일


오늘 날짜를 확인하기 (sysdate)

sysdate는 항상 그 날 날짜만 반환하기 때문에 괄호가 필요없는 듯하다.

select  sysdate 
  from  dual;

예제 : emp 사원이 입사한지 몇일이 지났는지 출력하기

select ename, round( sysdate - hiredate) 
 from  emp
 where hiredate is not null;

날짜와 날짜 사이의 개월 수를 반환(months_between)

months_between( 최신날짜, 옛날날짜) 

예제 : 사원이 지금까지 몇 달 근무했는지 출력하기

select ename || ' 은 ' || round(months_between(sysdate, hiredate)) || ' 달을 근무했습니다.'
 from emp;

n개월 수 더한 날짜 출력하기(ADD_MONTHS)

select  add_months( sysdate, 6 ) 
  from  dual;

특정 날짜 뒤에 오는 요일 날짜 출력하기 (NEXT_DAY)

예제 : 오늘 기준 다음 주 월요일의 날짜를 출력하기

select  next_day( sysdate, '월요일')
 from dual;

특정 날짜가 있는 달의 마지막 날짜 출력하기 (LAST_DAY)

예제 : 오늘 날짜와 이번 달의 마지막 날짜를 출력하기

select   sysdate,  last_day(sysdate)
   from  dual;

